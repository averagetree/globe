import { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';
import { h as hasSlot } from './utils.js';
import { d as defineCustomElement$2 } from './rux-icon2.js';
import { d as defineCustomElement$1 } from './rux-status2.js';

const ruxToastCss = ":host{display:contents;--height:auto;--iconSize:16px}.rux-toast{display:flex;align-items:center;align-content:center;box-sizing:border-box;width:calc((var(--spacing-20, 5rem) * 3) + (var(--spacing-10, 2.5rem)));border-radius:var(--radius-base, 3px);background:var(--color-background-base-default, #101923);padding:calc(var(--spacing-4, 1rem) + var(--spacing-050, 0.125rem)) var(--spacing-2, 0.5rem) calc(var(--spacing-4, 1rem) + var(--spacing-050, 0.125rem)) var(--spacing-4, 1rem);margin-block-start:var(--spacing-3, 0.75rem);min-height:calc(var(--spacing-14, 3.5rem) + var(--spacing-1, 0.25rem));height:var(--height);border:var(--border-width-xs, 1px) solid var(--color-border-interactive-default, #4dacff);font-family:var(--font-body-1-font-family, 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif);font-size:var(--font-body-1-font-size, 1rem);font-weight:var(--font-body-1-font-weight, 400);letter-spacing:var(--font-body-1-letter-spacing, 0.005em);line-height:var(--line-height-base, 1.5rem);opacity:inherit}.rux-toast__actions{margin-left:auto;margin-bottom:auto;display:flex}.rux-toast__close:focus-visible{border-radius:var(--radius-base, 3px);outline:var(--border-width-focus-default, 1px) solid var(--color-border-focus-default, #da9ce7);outline-offset:var(--spacing-focus-default, 0.125rem)}.rux-toast__content{display:flex;justify-content:center;align-items:center;gap:var(--spacing-4, 1rem)}.rux-toast__close{cursor:pointer}.rux-toast.rux-toast-status__standby{border-color:var(--color-status-standby, #2dccff)}.rux-toast.rux-toast-status__standby rux-icon::part(icon){color:var(--color-status-standby, #2dccff)}.rux-toast.rux-toast-status__critical{border-color:var(--color-status-critical, #ff3838)}.rux-toast.rux-toast-status__critical rux-icon::part(icon){color:var(--color-status-critical, #ff3838)}.rux-toast.rux-toast-status__serious{border-color:var(--color-status-serious, #ffb302)}.rux-toast.rux-toast-status__serious rux-icon::part(icon){color:var(--color-status-serious, #ffb302)}.rux-toast.rux-toast-status__caution{border-color:var(--color-status-caution, #fce83a)}.rux-toast.rux-toast-status__caution rux-icon::part(icon){color:var(--color-status-caution, #fce83a)}.rux-toast.rux-toast-status__off{border-color:var(--color-status-off, #a4abb6)}.rux-toast.rux-toast-status__off rux-icon::part(icon){color:var(--color-status-off, #a4abb6)}.rux-toast.rux-toast-status__normal{border-color:var(--color-status-normal, #56f000)}.rux-toast.rux-toast-status__normal rux-icon::part(icon){color:var(--color-status-normal, #56f000)}";

const RuxToast = /*@__PURE__*/ proxyCustomElement(class RuxToast extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ruxToastOpen = createEvent(this, "ruxtoastopen", 7);
    this.ruxToastClosed = createEvent(this, "ruxtoastclosed", 7);
    this._timeoutRef = null;
    this.hasMessageSlot = false;
    this.message = '';
    this.closeAfter = undefined;
    this.hideClose = false;
    this.status = undefined;
  }
  watchHandler() {
    this._updated();
  }
  connectedCallback() {
    this._handleSlotChange = this._handleSlotChange.bind(this);
    this._updated();
    this.hasMessageSlot = hasSlot(this.el);
    this._onClick = this._onClick.bind(this);
    this._onKeyPress = this._onKeyPress.bind(this);
  }
  componentDidLoad() {
    this._handleOpen();
  }
  _handleOpen() {
    this.ruxToastOpen.emit();
  }
  _handleClose() {
    this.ruxToastClosed.emit();
    this.el.remove();
  }
  _updated() {
    if (this._closeAfter) {
      this._timeoutRef = window.setTimeout(() => {
        this._handleClose();
      }, this._closeAfter);
    }
  }
  _onClick() {
    if (this._timeoutRef) {
      clearTimeout(this._timeoutRef);
    }
    this._handleClose();
  }
  _onKeyPress(e) {
    if (e.key === 'Enter') {
      this._onClick();
    }
  }
  get _closeAfter() {
    //* as long as it's less than 1000, they put in seconds. Convert that here.
    if (this.closeAfter && this.closeAfter <= 999) {
      //it's in seconds
      this.closeAfter *= 1000; // change into ms
    }
    if ((this.closeAfter && this.closeAfter > 10000) ||
      (this.closeAfter && this.closeAfter < 2000)) {
      // if this number is larger than 10s or smaller than 2s, enforce minimum 2s delay
      this.closeAfter = 2000;
    }
    return this.closeAfter;
  }
  _handleSlotChange() {
    this.hasMessageSlot = hasSlot(this.el);
  }
  render() {
    return (h(Host, null, h("div", { class: `rux-toast rux-toast-status__${this.status}`, part: "container" }, h("div", { class: {
        'rux-toast__content': true,
      }, part: "message" }, this.status ? (h("rux-status", { status: this.status })) : null, h("slot", { onSlotchange: this._handleSlotChange }), !this.hasMessageSlot && this.message ? (h("span", null, this.message)) : null), !this.hideClose ? (h("div", { class: "rux-toast__actions" }, h("rux-icon", { role: "button", tabindex: "1", class: "rux-toast__close", onClick: this._onClick, onKeyDown: this._onKeyPress, icon: "clear", exportparts: "icon", size: getComputedStyle(this.el).getPropertyValue('--iconSize') }))) : null)));
  }
  get el() { return this; }
  static get watchers() { return {
    "closeAfter": ["watchHandler"]
  }; }
  static get style() { return ruxToastCss; }
}, [1, "rux-toast", {
    "message": [513],
    "closeAfter": [1538, "close-after"],
    "hideClose": [516, "hide-close"],
    "status": [513],
    "hasMessageSlot": [32]
  }]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["rux-toast", "rux-icon", "rux-status"];
  components.forEach(tagName => { switch (tagName) {
    case "rux-toast":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, RuxToast);
      }
      break;
    case "rux-icon":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
    case "rux-status":
      if (!customElements.get(tagName)) {
        defineCustomElement$1();
      }
      break;
  } });
}

export { RuxToast as R, defineCustomElement as d };
