import { h, Host, } from '@stencil/core';
import { hasSlot, renderHiddenInput, renderHiddenSliderInput, } from '../../utils/utils';
let id = 0;
/**
 * @slot label - The slider label
 * @slot help-text - the help text
 * @slot error-text - the error text
 * @part error-text - The error text element
 * @part form-field - The form-field wrapper container
 * @part help-text - The help text element
 * @part input - The input element
 * @part label - The input label when `label` prop is set
 * @part tick-container - The container of the tick mark and axis-label
 * @part tick - the tick mark
 * @part axis-label - the axis label
 */
export class RuxSlider {
  constructor() {
    this.sliderId = `rux-slider-${++id}`;
    this._onBlur = () => {
      this.ruxBlur.emit();
    };
    this.hasLabelSlot = false;
    this.hasHelpSlot = false;
    this.hasErrorSlot = false;
    this.min = 0;
    this.max = 100;
    this.step = 1;
    this.value = (this.max - this.min) / 2 + this.min;
    this.axisLabels = [];
    this.ticksOnly = false;
    this.disabled = false;
    this.name = '';
    this.label = undefined;
    this.helpText = undefined;
    this.errorText = undefined;
    this.minVal = undefined;
    this.strict = false;
  }
  componentWillLoad() {
    this._setValuePercent();
    this._getBrowser(navigator.userAgent.toLowerCase());
    this._handleSlotChange();
  }
  connectedCallback() {
    this._onInput = this._onInput.bind(this);
    this._onMinValInput = this._onMinValInput.bind(this);
    this._onBlur = this._onBlur.bind(this);
    this._handleSlotChange = this._handleSlotChange.bind(this);
    this._onChange = this._onChange.bind(this);
    this._handleTrackClick = this._handleTrackClick.bind(this);
  }
  disconnectedCallback() {
    this.el.shadowRoot.removeEventListener('slotchange', this._handleSlotChange);
  }
  handleLabelChange() {
    this._handleSlotChange();
  }
  handleChange() {
    this._setValuePercent();
  }
  handleStep() {
    // Value needs to be a multiple of step, otherwise slider begins to look wrong
    this.value = this._closestMultiple(this.value);
    if (this.minVal)
      this.minVal = this._closestMultiple(this.minVal);
  }
  get hasLabel() {
    return this.label ? true : this.hasLabelSlot;
  }
  /**
   * Returns the closest multiple of two given numbers.
   */
  _closestMultiple(x) {
    return Math.round(x / this.step) * this.step;
  }
  //Sets the --slider-value-percent CSS var.
  _setValuePercent() {
    //if minVal is being used, we're in dual range mode.
    if (this.minVal !== undefined) {
      if (this.minVal > this.value) {
        this.el.style.setProperty('--_slider-value-percent', `${this.minVal}%`);
        this.el.style.setProperty('--_start-value-percent', `${this.value}%`);
        //If end < start, no need to swap
      }
      else {
        this.el.style.setProperty('--_start-value-percent', `${this.minVal}%`);
        this.el.style.setProperty('--_slider-value-percent', `${this.value}%`);
      }
      //if not in dual slider
    }
    else {
      const dif = ((this.value - this.min) / (this.max - this.min)) * 100;
      this.el.style.setProperty('--_slider-value-percent', `${dif}%`);
    }
  }
  _onInput(e) {
    const target = e.target;
    if (this.value !== undefined) {
      this.value = parseFloat(target.value);
      if (this.value <= this.minVal && this.strict) {
        this.value = this.minVal;
        target.value = this.value.toString();
      }
    }
    this._setValuePercent();
    this.ruxInput.emit();
  }
  _onMinValInput(e) {
    const target = e.target;
    this.minVal = parseFloat(target.value);
    if (this.minVal >= this.value && this.strict) {
      this.minVal = this.value;
      target.value = this.minVal.toString();
    }
    this._setValuePercent();
    this.ruxInput.emit();
  }
  _onChange() {
    this.ruxChange.emit();
  }
  _getBrowser(ua) {
    //Safari needs 0px top for the thumb to look normal.
    //Safari needs differnet padding on ticks.
    if (ua.indexOf('safari') > -1 && ua.indexOf('chrome') == -1) {
      this.el.style.setProperty('--_slider-top', '0px');
      this.el.style.setProperty('--slider-tick-padding-top', '7px');
    }
    //firefox - thumb too large, tick padding not enough
    if (ua.indexOf('firefox') > -1) {
      this.el.style.setProperty('--slider-tick-padding-top', '3px');
      //? Better to set this here, or in the css with a calc(--slider-thumb-size - 4px)?
      // this.el.style.setProperty('--slider-thumb-size', '15px')
    }
  }
  _handleSlotChange() {
    this.hasLabelSlot = hasSlot(this.el, 'label');
    this.hasErrorSlot = hasSlot(this.el, 'error-text');
    this.hasHelpSlot = hasSlot(this.el, 'help-text');
  }
  _getTickWidths() {
    if (this.axisLabels) {
      const width = 100 / (this.axisLabels.length - 1);
      return width;
    }
  }
  /**
   * Given the position of the click on a dual range slider, move the appropiate thumb to that
   * postion.
   * @param e The click event. This is attatched to the .rux-slider div.
   * @returns Depnding on values and the click location, this will update either
   * minVal or value.
   */
  _handleTrackClick(e) {
    // if the minVal isn't being used, we're not in dual mode, so do nothing. Do nothing if disabled.
    if (this.minVal === undefined || this.disabled)
      return;
    const target = e.target;
    // if the clicked target is one of the thumbs or the overlay, do nothing
    // inputs have pointer-events: none, thumbs do not. If the nodeName is an input, then
    // the thumb was clicked.
    //* For now, the overlay bar is non-clickable as well.
    if (target.nodeName === 'INPUT' ||
      target.classList.contains('rux-range-overlay'))
      return;
    // Find the size of the element
    const currentTarget = e.currentTarget;
    const sliderWidth = currentTarget.offsetWidth;
    const sliderBounds = currentTarget.getBoundingClientRect();
    // get the click's distance from the left side
    const clickPosition = e.clientX - sliderBounds.left;
    // format clickPosition
    let percentFromLeft = Math.round((clickPosition / sliderWidth) * 100);
    percentFromLeft = this._closestMultiple(percentFromLeft);
    // Prevent stlying bug when clicking the upper end of the slider while the step is
    // not a multiple of the max
    if (percentFromLeft > this.max)
      percentFromLeft = this.max - this.step;
    // get the percent of the min and max value for comparison
    let minValPercent = Math.round(this.minVal);
    let maxValPercent = Math.round(this.value);
    //When thumbs have swapped, we need to swap these as well.
    if (this.minVal > this.value) {
      minValPercent = Math.round(this.value);
      maxValPercent = Math.round(this.minVal);
    }
    //if click happens between the thumbs, ignore it. //* Might be changed in future
    if (percentFromLeft > minValPercent &&
      percentFromLeft < maxValPercent) {
      return;
    }
    // compares minValPercent and maxValPercent to percentFromLeft, and returns which one is the closest.
    let counts = [minValPercent, maxValPercent];
    var closest = counts.reduce(function (prev, curr) {
      return Math.abs(curr - percentFromLeft) <
        Math.abs(prev - percentFromLeft)
        ? curr
        : prev;
    });
    //handle case where thumbs overlap
    if (this.value === this.minVal) {
      //then we need to just move the left thumb if clicked to the left, right thumb if clicked to right
      if (percentFromLeft > closest) {
        //move right thumb
        this.value = percentFromLeft;
      }
      else {
        this.minVal = percentFromLeft;
      }
    }
    else {
      if (closest === maxValPercent) {
        this.value = percentFromLeft;
      }
      else {
        this.minVal = percentFromLeft;
      }
    }
    this.ruxInput.emit();
  }
  render() {
    const { el, sliderId, label, errorText, helpText, hasLabel, hasErrorSlot, hasHelpSlot, _handleSlotChange, min, max, value, step, disabled, name, _onInput, _onBlur, _onChange, _handleTrackClick, axisLabels, _onMinValInput, minVal, ticksOnly, } = this;
    renderHiddenInput(true, el, name, JSON.stringify(value), disabled);
    if (minVal !== undefined) {
      renderHiddenSliderInput(true, el, name ? `${name}-min-val` : '', JSON.stringify(minVal), disabled);
    }
    return (h(Host, null, h("div", { class: "rux-form-field", part: "form-field" }, hasLabel ? (h("label", { class: {
        'rux-input-label': true,
        hidden: !hasLabel,
      }, "aria-hidden": hasLabel ? 'false' : 'true', htmlFor: sliderId, part: "label" }, h("slot", { name: "label" }, label))) : null, h("div", { class: {
        'rux-slider': true,
        'rux-slider--range': minVal !== undefined ? true : false,
      }, onClick: _handleTrackClick }, minVal !== undefined ? (h("input", { type: "range", class: "rux-range rux-range--dual", onInput: _onMinValInput, onChange: _onChange, disabled: disabled, min: min, max: max, step: step, value: minVal, onBlur: _onBlur })) : null, h("input", { id: sliderId, onInput: _onInput, onChange: _onChange, type: "range", class: {
        'rux-range': true,
        'rux-range--dual': minVal !== undefined ? true : false,
      }, min: min, max: max, step: step, value: value, disabled: disabled, "aria-label": "slider", "aria-disabled": disabled ? 'true' : 'false', onBlur: _onBlur, part: "input" }), minVal !== undefined ? (h("div", { class: "rux-range-overlay" })) : null), axisLabels.length > 0 ? (h("datalist", { id: "steplist", style: {
        gridTemplateColumns: `[tick] repeat(${axisLabels.length - 1}, ${this._getTickWidths()}%)`,
      } }, axisLabels.map((label) => {
      return (h("div", { class: "tick-label", part: "tick-container" }, h("div", { class: "tick", part: "tick" }), ticksOnly ? null : (h("div", { class: "axis-label", part: "axis-label" }, label))));
    }))) : null), h("div", { class: {
        'rux-error-text': !!errorText || hasErrorSlot,
        hidden: !errorText && !hasErrorSlot,
      }, part: "error-text" }, h("svg", { fill: "none", width: "14", height: "14", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 14 14" }, h("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M11.393 12.25c.898 0 1.458-.974 1.009-1.75L8.009 2.91a1.166 1.166 0 0 0-2.018 0L1.598 10.5c-.449.776.111 1.75 1.01 1.75h8.784ZM7 8.167a.585.585 0 0 1-.583-.584V6.417c0-.321.262-.584.583-.584.32 0 .583.263.583.584v1.166c0 .321-.262.584-.583.584Zm-.583 1.166V10.5h1.166V9.333H6.417Z", fill: "currentColor" })), h("slot", { name: "error-text", onSlotchange: _handleSlotChange }, errorText)), h("div", { class: {
        'rux-help-text': (!!helpText || hasHelpSlot) &&
          (!errorText || !hasErrorSlot),
        hidden: (!helpText && !hasHelpSlot) ||
          !!errorText ||
          hasErrorSlot,
      }, part: "help-text" }, h("slot", { name: "help-text", onSlotchange: _handleSlotChange }, helpText))));
  }
  static get is() { return "rux-slider"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["rux-slider.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["rux-slider.css"]
    };
  }
  static get properties() {
    return {
      "min": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Min value of the slider."
        },
        "attribute": "min",
        "reflect": false,
        "defaultValue": "0"
      },
      "max": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Max value of slider."
        },
        "attribute": "max",
        "reflect": false,
        "defaultValue": "100"
      },
      "step": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Step amount of slider value."
        },
        "attribute": "step",
        "reflect": false,
        "defaultValue": "1"
      },
      "value": {
        "type": "number",
        "mutable": true,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Current value of the slider. The default value is halfway between the specified minimum and maximum. - [HTMLElement/input_type_range>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range) In dual-range, this value should be higher than the min-val."
        },
        "attribute": "value",
        "reflect": true,
        "defaultValue": "(this.max! - this.min!) / 2 + this.min!"
      },
      "axisLabels": {
        "type": "unknown",
        "mutable": false,
        "complexType": {
          "original": "string[]",
          "resolved": "string[]",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Shows tick marks and labels in the order provided and aligns evenly based on the length."
        },
        "defaultValue": "[]"
      },
      "ticksOnly": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Hides labels and only shows tick marks if axis-labels is provided."
        },
        "attribute": "ticks-only",
        "reflect": false,
        "defaultValue": "false"
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Determines if the slider is disabled."
        },
        "attribute": "disabled",
        "reflect": true,
        "defaultValue": "false"
      },
      "name": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Name of the Input Field for Form Submission"
        },
        "attribute": "name",
        "reflect": false,
        "defaultValue": "''"
      },
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string | undefined",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "The slider label text. For HTML content, use the `label` slot instead."
        },
        "attribute": "label",
        "reflect": false
      },
      "helpText": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string | undefined",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "The help or explanation text"
        },
        "attribute": "help-text",
        "reflect": false
      },
      "errorText": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string | undefined",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "The validation error text"
        },
        "attribute": "error-text",
        "reflect": false
      },
      "minVal": {
        "type": "number",
        "mutable": true,
        "complexType": {
          "original": "number",
          "resolved": "number | undefined",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "If present, creates a dual-range slider by adding a second thumb."
        },
        "attribute": "min-val",
        "reflect": true
      },
      "strict": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "In a dual-range slider, disables thumb swapping."
        },
        "attribute": "strict",
        "reflect": true,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "hasLabelSlot": {},
      "hasHelpSlot": {},
      "hasErrorSlot": {}
    };
  }
  static get events() {
    return [{
        "method": "ruxInput",
        "name": "ruxinput",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Fired when the value of the input changes - [HTMLElement/input_event](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)"
        },
        "complexType": {
          "original": "any",
          "resolved": "any",
          "references": {}
        }
      }, {
        "method": "ruxBlur",
        "name": "ruxblur",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Fired when an element has lost focus - [HTMLElement/blur_event](https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event)"
        },
        "complexType": {
          "original": "any",
          "resolved": "any",
          "references": {}
        }
      }, {
        "method": "ruxChange",
        "name": "ruxchange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Fired when the element's value is altered by the user - [HTMLElement/change_event](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)"
        },
        "complexType": {
          "original": "any",
          "resolved": "any",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "el"; }
  static get watchers() {
    return [{
        "propName": "label",
        "methodName": "handleLabelChange"
      }, {
        "propName": "value",
        "methodName": "handleChange"
      }, {
        "propName": "min",
        "methodName": "handleChange"
      }, {
        "propName": "max",
        "methodName": "handleChange"
      }, {
        "propName": "minVal",
        "methodName": "handleChange"
      }, {
        "propName": "step",
        "methodName": "handleStep"
      }];
  }
}
